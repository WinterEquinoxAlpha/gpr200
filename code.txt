#define colorRGB vec3
#define PI 3.14159265358979323846264338327950288419
#define PHI 1.61803398874989484820459

// Starter code from Daniel Buckstein
// Modified by Michael Kashian
vec4 myEffect0( in vec2 fragCoord, in vec2 resolution )
{
    // Calculates the color vector
    vec2 uv = fragCoord / resolution;
    return vec4(uv, 0.5, 1.0);
}

vec4 myEffect1( in vec2 fragCoord, in float squareSize )
{
    // Calculates the column position of the pixel
    float pixelColumnPosition = floor(mod(fragCoord.x, squareSize));
    // Calculates the row position of the pixel
    float pixelRowPosition = floor(mod(fragCoord.y, squareSize));
    
    // Determines if the row and column of the pixel should be black or white and sets it accordingly
    if ((pixelColumnPosition <= squareSize / 2.0 && pixelRowPosition > squareSize / 2.0) || (pixelRowPosition <= squareSize / 2.0 && pixelColumnPosition > squareSize / 2.0))
    {
        return vec4(0, 0, 0, 1);
    } else {
        return vec4(1, 1, 1, 1);
    }
}

vec4 myEffect2( in vec2 fragCoord, in vec2 resolution, in float time, in float startRadius, in float endRadius )
{
    // Calculates the radius of the circle based on the time and the start and end radii
    float radius = -cos(time) * ((endRadius - startRadius) / 2.0) + ((endRadius + startRadius) / 2.0);
    // The center of the circle
    vec2 center = vec2(resolution.x / 2.0, resolution.y / 2.0);
    
    // Variables for the color function
    float flattenValue = 2.5;
    float wavelength = 5.0;
    float rOffset = 0.0;
    float gOffset = 2.0;
    float bOffset = 4.0;
    // Determines the color of the circle and background based on this equation: sqrt((1+b^2)/(1+b^2*cos(x)^2)*cos(x)
    float r = 0.5 * sqrt( (1.0 + flattenValue * flattenValue) / (1.0 + flattenValue * flattenValue * cos(PI / wavelength * time + rOffset) * cos(PI / wavelength * time + rOffset)) ) * cos(PI / wavelength * time + rOffset) + 0.5;
    float b = 0.5 * sqrt( (1.0 + flattenValue * flattenValue) / (1.0 + flattenValue * flattenValue * cos(PI / wavelength * time + gOffset) * cos(PI / wavelength * time + gOffset)) ) * cos(PI / wavelength * time + gOffset) + 0.5;
    float g = 0.5 * sqrt( (1.0 + flattenValue * flattenValue) / (1.0 + flattenValue * flattenValue * cos(PI / wavelength * time + bOffset) * cos(PI / wavelength * time + bOffset)) ) * cos(PI / wavelength * time + bOffset) + 0.5;
    // The colors for the circle and background
    vec3 circleColor = vec3(r, g, b);
    vec3 bgColor = vec3(b, r, g);
    
    // If the pixel is within the radius of the circle, color it accordingly
    if (distance(fragCoord, center) <= radius)
    {
        return vec4(circleColor, 1.0);
    } else {
        return vec4(bgColor, 1.0);
    }
}

// Calculates the linear Interpolation value for the mix() function based on a start and end point on the screen
float findLerp( in float start, in float end, in vec2 fragCoord)
{
    float dnom = end - start;
    return (fragCoord.y / dnom) - (start / dnom);
}

// RNG code from "Gold Noise Uniform Random Static" by dcerisano
// https://www.shadertoy.com/view/ltB3zD
// Modified by Michael Kashian
float random(in vec2 xy, in float seed)
{
    return fract(tan(distance(xy * PHI, xy) * seed) * xy.x);
}


vec4 myEffect3(in vec2 fragCoord, in vec2 resolution, in float time, in float seed )
{
    vec4 finalColor;	// The color returned by the function
    float radius = resolution.y / 4.0;	// The radius of the sun
    float groundHeight = resolution.y / 3.0;	// The height of the ground
    float centerOfSky = (resolution.y + groundHeight) / 2.0;	// The center of the sky above the ground
    float yPos = mod(resolution.y / 2.0 - time * 100.0, resolution.y + radius);	// The y-position of the sun
    vec2 center = vec2(yPos * (resolution.x / resolution.y), yPos);	// The center of the sun
    
    // Determines what part of the image the pixel is part of
    // If the pixel is below the ground height...
    if (fragCoord.y < groundHeight)
    {
        // Ground
        
        // Determines the color of the gradient
        float lerp = findLerp(groundHeight, 0.0, fragCoord);
        // Determines how bright the ground should be based on the position of the sun
        float colorPercent = (((resolution.y + radius) - centerOfSky) - distance(center.y, centerOfSky)) / ((resolution.y + radius) - centerOfSky);
        // Sets the pixel's color based on the two above statements
        finalColor = vec4(mix(colorPercent * 1.0, colorPercent * 0.1, lerp), mix(colorPercent * 0.19, colorPercent * 0.1, lerp), mix(colorPercent * 0.87, colorPercent * 0.3, lerp), 1.0);
    }
    // If the pixel is within the radius of the sun and does not fall on certian lines...
    else if (distance(fragCoord, center) <= radius && distance(fragCoord.y, center.y) > 1.0 && distance(fragCoord.y, center.y - radius / 6.0) > 1.5 && distance(fragCoord.y, center.y - radius / 3.0) > 2.0 && distance(fragCoord.y, center.y - radius / 2.0) > 4.0 && distance(fragCoord.y, center.y - radius / 1.4) > 6.0) {
        // Sun
        
        // Determines the color of the gradient
        float lerp = findLerp(center.y - radius, center.y + radius, fragCoord);
        // Sets the pixel's color based on the above statement
        finalColor = vec4(mix(0.878, 0.93, lerp), mix(0.117, 0.55, lerp), mix(0.596, 0.39, lerp), 1.0);
    }
    // If the pixel is above the ground and not in the sun...
    else {
        // Sky
        
        // Determines the color of the gradient
        float lerp = findLerp(resolution.y, groundHeight, fragCoord);
        // Sets the pixel's color based on the above statement
        finalColor = vec4(mix(0.1, 0.7, lerp), 0.0, mix(0.3, 0.59, lerp), 1.0);
        
        // Stars
        
        // List of points for stars
        vec2 points[100];
        // Go throught the array and set each vector to a random point on the screen
        for (int i = 0; i < points.length(); i++)
        {
            float rnd1 = random(vec2(i, i), fract(seed) + 1.0);
            float rnd2 = random(vec2(i, i), fract(seed) + 2.0);
            points[i] = vec2(iResolution.x * rnd1, mod((iResolution.y * rnd2) + (time * 1000.0), resolution.y));
        }
        
        // The size of the stars
        float starRadius = 2.0;
        // Go through each point and determine if the pixel is close enough to it to be a star
        for (int i = 0; i < points.length(); i++)
    	{
            if (distance(fragCoord, points[i]) <= starRadius)
            {
                finalColor = vec4(1.0, 1.0, 1.0, 1.0);
            }
        }
    }
    return finalColor;
}

// mainImage: calculate and pass final display color of current pixel
//  fragColor: final color to be displayed; assigned by function
//    (4D vector representing a color in RGBA format)https://www.shadertoy.com/img/themes/classic/help.png
//  fragCoord: coordinate of current pixel being processed
//    (2D vector representing the location of the pixel in the image)
//      x: between zero and horizontal display resolution (zero is left side of image)
//      y: between zero and vertical display resolution (zero is bottom of image)
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = myEffect0(fragCoord, iResolution.xy);
    //fragColor = myEffect1(fragCoord, 100.0);
    //fragColor = myEffect2(fragCoord, iResolution.xy, iTime, 100.0, 200.0);
    //fragColor = myEffect3(fragCoord, iResolution.xy, iTime, iResolution.x);
}