#define colorRGB vec3

// Starter code from Daniel Buckstein
// Modified by Michael Kashian
vec4 myEffect0( in vec2 fragCoord, in vec2 resolution )
{
    // Calculates the color vector
    vec2 uv = fragCoord / resolution;
    return vec4(uv, 0.5, 1.0);
}

vec4 myEffect1( in vec2 fragCoord, in float squareSize )
{
    // Calculates the column position of the pixel
    float pixelColumnPosition = floor(mod(fragCoord.x, squareSize));
    // Calculates the row position of the pixel
    float pixelRowPosition = floor(mod(fragCoord.y, squareSize));
    
    // Determines if the row and column of the pixel should be black or white and sets it accordingly
    if ((pixelColumnPosition <= squareSize / 2.0 && pixelRowPosition > squareSize / 2.0) || (pixelRowPosition <= squareSize / 2.0 && pixelColumnPosition > squareSize / 2.0))
    {
        return vec4(0, 0, 0, 1);
    } else {
        return vec4(1, 1, 1, 1);
    }
}

vec4 myEffect2( in vec2 fragCoord, in vec2 resolution, in float time, in float startRadius, in float endRadius )
{
    // Calculates the radius of the circle based on the time and the start and end radii
    float radius = -cos(time) * ((endRadius - startRadius) / 2.0) + ((endRadius + startRadius) / 2.0);
    // The center of the circle
    vec2 center = vec2(resolution.x / 2.0, resolution.y / 2.0);
    
    // Variables for the color function
    float flattenValue = 2.5;
    float wavelength = 5.0;
    float rOffset = 0.0;
    float gOffset = 2.0;
    float bOffset = 4.0;
    // Determines the color of the circle and background based on this equation: sqrt((1+b^2)/(1+b^2*cos(x)^2)*cos(x)
    float r = 0.5 * sqrt( (1.0 + flattenValue * flattenValue) / (1.0 + flattenValue * flattenValue * cos(PI / wavelength * time + rOffset) * cos(PI / wavelength * time + rOffset)) ) * cos(PI / wavelength * time + rOffset) + 0.5;
    float b = 0.5 * sqrt( (1.0 + flattenValue * flattenValue) / (1.0 + flattenValue * flattenValue * cos(PI / wavelength * time + gOffset) * cos(PI / wavelength * time + gOffset)) ) * cos(PI / wavelength * time + gOffset) + 0.5;
    float g = 0.5 * sqrt( (1.0 + flattenValue * flattenValue) / (1.0 + flattenValue * flattenValue * cos(PI / wavelength * time + bOffset) * cos(PI / wavelength * time + bOffset)) ) * cos(PI / wavelength * time + bOffset) + 0.5;
    // The colors for the circle and background
    vec3 circleColor = vec3(r, g, b);
    vec3 bgColor = vec3(b, r, g);
    
    // If the pixel is within the radius of the circle, color it accordingly
    if (distance(fragCoord, center) <= radius)
    {
        return vec4(circleColor, 1.0);
    } else {
        return vec4(bgColor, 1.0);
    }
}

// mainImage: calculate and pass final display color of current pixel
//  fragColor: final color to be displayed; assigned by function
//    (4D vector representing a color in RGBA format)https://www.shadertoy.com/img/themes/classic/help.png
//  fragCoord: coordinate of current pixel being processed
//    (2D vector representing the location of the pixel in the image)
//      x: between zero and horizontal display resolution (zero is left side of image)
//      y: between zero and vertical display resolution (zero is bottom of image)
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    //fragColor = myEffect0(fragCoord, iResolution.xy);
	//fragColor = myEffect1(fragCoord, 100.0);
	fragColor = myEffect2(fragCoord, iResolution.xy, iTime, 100.0, 200.0);
}